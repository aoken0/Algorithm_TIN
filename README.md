# Algorithm_TIN


## TINアルゴリズム(グリッドからTIN)
1. TINに含まれるすべての頂点$v$について :
    
    * 一時的に頂点 $v$ を削除．
    * 削除した頂点を除いて，Delaunay三角網を構築．
    * 新たなTINを用いて，頂点 $v$ の標高誤差 $error(v)$ を計算．

    ソートされた各頂点 $v$ の誤差 $error(v)$ を 平衡二分木(balanced binary tree) $T$ に格納する． $T$ の各ノードは誤差 $error(v)$ とTINの頂点 $v$ へのポインタを保持している．  
    また頂点 $v$ には， $T$ の対応するノードへのポインタを格納する.

2. $T$ において，最小の $error(v)$ を持つノードについて検討する．もしその $error(v)$ が，設定した最大誤差よりも大きければ，ここでアルゴリズムを終了する．そうでないとき，次のステップへ進む．

3. $error(v)$ を持つ $T$ のノードを削除する．そして対応する頂点 $v$ をTIN構造体から削除する．  
頂点 $v$ の隣接する頂点を $w_1, w_2, ..., w_j$ とする．そして頂点 $w_1, w_2, ..., w_j$ を用いて，再度ドローネ三角分割を行う．

4. すべての頂点 $w_i \in \{w_1, w_2, ..., w_j\}$ について : 

    * $error(w_i)$ を保持しているノードを $T$ から削除．
    * Step1で行ったように，頂点 $w_i$ を削除した際の標高誤差 $error(w_i)$ を計算．
    * 新たに求めた $error(w_i)$ を $T$ に代入．

Step2へ続く  


#### 参考文献
> Marc van Kreveld，Jürg Nievergelt，Thomas Roos，Peter Widmayer (Eds.): Algorithmic Foundations of Geographic Information Systems，Springer，pp．47-50，1997．



## ドローネ三角分割(Delaunay Triangulation)

アルゴリズムに関する情報は，[Algorithm_Delaunay](https://github.com/aoken0/Algorithm_Delaunay) を参照．


## 重心座標系(Barycentric coordinate system)

ある三角形に内包されている点について、標高を線形補間で求める。

### 数式等
任意の点を $P$ ，点 $P$ を内包する三角形の頂点をそれぞれ $A, B, C$ とする．またそれぞれの点の標高(重み)は $P_h, A_h, B_h, C_h$ とする．  
重心座標系を用いると任意の点 $P$ の座標・標高は以下のように表せる．

```math
\begin{align*}
P &= \lambda_1 A + \lambda_2 B + \lambda_2 C \\
P_h &= \lambda_1 A_h + \lambda_2 B_h + \lambda_2 C_h \\
\end{align*}
```

&emsp;

そして $\lambda_1, \lambda_2, \lambda_3$ は以下のように求められる．  
面積を $area()$ として， 

```math
\begin{align*}
\lambda_1 &=& area(PBC) / area(ABC) \\
\lambda_2 &=& area(APC) / area(ABC) \\
\lambda_3 &=& area(ABP) / area(ABC) \\
\end{align*}
```

となる．また

```math
\begin{align*}
1 = \lambda_1 + \lambda_2 + \lambda_3
\end{align*}
```

である．

ここで面積はベクトルの外積を用いて求めた．  
例)

```math
\begin{align*}
area(ABC) = \frac{1}{2} AB \times AC
\end{align*}
```

> 参考  
> * https://en.wikipedia.org/wiki/Barycentric_coordinate_system



## 実装について

### 不完全なグリッドで分割を行う

グリッド状の点が完全なグリッドであると，delaunay分割の際に分割対象に選択した点群の数や組合せによって異なるdelaunay三角網を返してしまう．

そのため，横もしくは縦方向に少しだけずらした不完全なグリッドを用いることで点群の数や組合せによってdelaunay三角網が異なることを避ける．  

実際最終的な分割目的であるDEMは緯度経度方向で長さが異なり不完全なグリッドであるため，そのまま実行すればよいことになる．

### 現状の実行速度

実行速度は関数を呼び出した瞬間から、最終のTINが取得できるまでの時間で測る．

またアルゴリズムのループにて，debugのために最小標高誤差を出力する(無駄な)処理が入っている．そのため少しだけ実行速度は落ちている．

許容最大誤差が0.1のとき
| 点の数 | 時間 |
|----|----|
| 400 | 6s |
| 2500 | 2m46s |
| 10000 | 46m |

### 実行速度短縮に向けて

現状の実行速度では研究本体に使うグリッド状の点数約75万個を処理するのにとてつもない時間がかかってしまう．そのため，計算時間を短縮するため，工夫してみる．

検証はグリッド状にランダムに生成された $50\times50=2500$ 個の点についてTIN分割を行い，それぞれの実行時間に基づいて行う．

以下は既存のTIN分割関数から工夫した点である．
1. pandasのDataframeをすべてnumpyのndarrayに変換してから処理

2. Step1のすべての点の標高誤差を求める処理にて，削除する点の周囲(最大)24点のみからdelaunay分割を行うようにする．

3. Step3の削除した点に隣接する点の標高誤差の再計算時にdelaunay分割を行う点を制限する．具体的には削除点に接続する3つ先までの点群に対してdelaunay分割を行う．

そして実行時間は以下の表に示す．

最大許容誤差が0.1のとき
| 工夫 | 実行時間 |
| ---- | ---- |
| 既存 | 163s |
| 工夫1 | 150s |
| 工夫1~2 | 116s |
| 工夫1~3 | 31s |

#### 工夫3について
工夫2までの処理後の点数と比べると2点多く残ってしまっている．しかし全体的な形は変わりなく、1640点が1642点になっているだけなので現段階では許容する．

#### その他実行時間

下記表の実行時間は上記の工夫1~3を実装したうえでのものである．またdebug用のprintは削除して実行している．

最大許容誤差が0.1のとき
|  | 実行時間 |
| ---- | ---- |
| 2500点 | 27s |
| 10000点 | 6m10s |




